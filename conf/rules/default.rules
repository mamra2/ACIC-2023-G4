// Initialize bot (on Telegram)
val telegramBot = getActions("telegram","telegram:telegramBot:telegrambot")

// Device & Wallpug
rule "Toggle Wallplug"
    when
        Item MyDeviceIsOnline changed
    then
        Wallplug_Hall.sendCommand(MyDeviceIsOnline.state.toString)
end

// Telegram
rule "Send Text"
    when 
        Item Telegram_Message received update "email"
    then
        var message = Telegram_Message.state.toString
        if(message == "email" || message == "Email"){
            telegramBot.sendTelegram("To?")
            telegramBot.sendTelegram("Subject?")
            telegramBot.sendTelegram("Body?")

            var String[] test = message.split(",")
            telegramBot.sendTelegram(test)
        }
end
rule "Receive Message (on Telegram)"
    when 
        //Change this trigger message
        Item Telegram_Message received update "message test"
    then
        var message = Telegram_Message.state.toString
        //val telegramBot = getActions("telegram","telegram:telegramBot:telegrambot")
        if (message == "ON" || message == "OFF") {
            Test_Switch.sendCommand(message)
            telegramBot.sendTelegram("Switch changed state to " + message)
        }
        else {
            telegramBot.sendTelegram("Switch didn't change state because the message sent was \n\"" + message + "\"")
        }
        // Send to Henrique
        //telegramBot.sendTelegram(5680556583L, "This is a message for you, Henrique!")
end
rule "Query (on Telegram)"
    when
        //Change this trigger message
        Item Telegram_Message received update "reply test"
    then
        //val telegramBot = getActions("telegram","telegram:telegramBot:telegrambot")
        telegramBot.sendTelegramQuery("Do you also want to receive a notification through e-mail?", "Telegram_Reply", "Yes", "No")
end
rule "Reply (on Telegram)"
    when
        Item Telegram_ReplyId received update "Telegram_Reply"
    then
        //val telegramBot = getActions("telegram","telegram:telegramBot:telegrambot") 
        var message = Telegram_Message.state.toString
        var notificationConfirmation = (
            if (message == "Yes") ("E-mail") 
            else if (message == "No") ("No"))
        telegramBot.sendTelegramAnswer(Telegram_ReplyId.state.toString, notificationConfirmation + " notification was sent.")
end
rule "Calendar Event Message (on Telegram)"
    when 
        Item Telegram_Message received update "Event started" or
        Item Telegram_Message received update "Event ended"
    then
        telegramBot.sendTelegram(Test_Switch.name + "'s state was set to " + Test_Switch.state.toString + ", as expected.")
        telegramBot.sendTelegram("The message defined in the calendar event's description was \n\"" + Telegram_Message.state.toString + "\"")
end

// Twitter
rule "Send tweet (on Twitter)"
    when
//        Item Test_Switch received update
        Item Telegram_Message received update "Send Tweet"
    then
        val tweetActions = getActions("twitter","twitter:account:account")
        // Send tweet
        val mention = "@openHAB"
        val tweetMessage = "This is a new Tweet sent for a uni project " + "(with " + mention + ")"
        tweetActions.sendTweet(tweetMessage)
        logInfo("Twitter", "Twitter sent with message \"" + tweetMessage + "\"")
end

// Mail
rule "Send e-mail"
    when 
//        Item Test_Switch received update+
        Item Telegram_Message received update "Send e-mail"
    then
        val receiver = "mamra2@iscte-iul.pt"
        val mailSubject = "[ACIC] openHAB (Teste de Laboratório)"
        val mailContent = "Para efeitos de laboratório, envia-se esta mensagem."
        val mailActions = getActions("mail","mail:smtp:smtp")
        mailActions.sendMail(receiver, mailSubject, mailContent)
end

// IFTTT
rule "Send IFTTT Notification"
    when
//        Item Test_Switch received update
        Item Telegram_Message received update "Send IFTTT Notification"
    then
        logInfo("LineBlock","\n" 
            + "//======================================================================================================================================================//")
        // Item Values
        var item = Test_Switch
        var itemName = item.name
        var itemState = item.state

        // IFTTT parameters
        var String ifttt_event = 'OH_Alarm'
        var String ifttt_key = 'opv4AxqQo6hB48Td9nep-E_Y4SKpDPUHNLAkO2izXCx'
        var String ifttt_values = '?value1=' + itemName + '&value2=' + itemState
        var String ifttt_url = 'https://maker.ifttt.com/trigger/' + ifttt_event + '/with/key/' + ifttt_key + ifttt_values

        // POST HTTP Request
        sendHttpPostRequest(ifttt_url)
        logInfo("IFTT", "IFTTT Notification => " + "Item {} has state {}.", itemName, itemState)
        logInfo("URL", "Sent to \nURL \"{}\"", ifttt_url)
end

// LoRa
rule "Publish MQTT Topic"
    when 
//        Item Test_Switch received update
        Item Telegram_Message received update "Publish MQTT topic"
    then
        val topic = "v3/ttn-backdior-app@ttn/devices/eui-0025ca0a00014919/up"
        val value = "The temperature is " + LoRa_AirTemperature.state.toString
        logInfo("LoRa", "LoRa Air Temperature is {}", LoRa_AirTemperature.state.toString)
        val retained = true
        val mqttActions = getActions("mqtt","mqtt:broker:broker")
        mqttActions.publishMQTT(topic, value, retained)
end

// XBee
rule "NewBinarySerialRule"
    when
        Item XBeeBinary changed 
    then
        //just logging the incoming binary string of the RXpacket (not really necessary for the integration)
        logInfo("XBee", "Incoming binary: {}", XBeeBinary.state)
        //Base64 decoding of the RXpacket
        val byte[] bytes = RawType.valueOf(XBeeBinary.state.toString()).getBytes()
        val char[] hexChars = newCharArrayOfSize(bytes.length() * 2)
        //just logging the RXpacket in HEX (not really necessary for the integration, if only using 1 sensor)
        //If multiple sensors are sending values one may have to use the source address to map the value to the apropriate Item
        val char[] hexArray = "0123456789ABCDEF".toCharArray()
        for (var j = 0; j < bytes.length(); j++) { 
            var int v = bytes.get(j).bitwiseAnd(0xFF)
            hexChars.set(j * 2, hexArray.get(v >>> 4))
            hexChars.set(j * 2 + 1, hexArray.get(v.bitwiseAnd(0x0F)))
        }
        val outString = new String(hexChars)
        //logInfo( "XBee", "Incoming binary decoded: {}", outString)
        //we know the exact position where the data is. 
        var int receivedtemp = bytes.get(15).bitwiseAnd(0xFF) * 256 + bytes.get(16).bitwiseAnd(0xFF)
        //updating the Item, with units conversions: 3300 mV of reference voltage and 10 bit resolution (1024 levels)
        val temp = Math::round( ( receivedtemp * 3300.0 / 1024 - 500).floatValue() * 10 ) / 100.0
        XBeeTemperature.postUpdate(temp)
        logInfo("XBee", "Incoming temperature from device ID {}: {}", outString.substring(8,24), XBeeTemperature.state) 
end
rule "XBeeLedRule"
    when
        Item XBeeLed changed 
    then
        if (XBeeLed.state == OFF) { 
            //header: |start|length |type |ID |8 byte address |net addr |broad|optio
            var msg = "\u007E\u0000\u000F\u0010\u0000\u0000\u0013\u00A2\u0000\u0040\u0092\u00FF\u007A\u00FF\u00FE\u0000\u0000"
            //determining header parcial checksum
            var int sum = 0x10+ 0x00+ 0x00+ 0x13+ 0xA2+ 0x00+ 0x40+ 0x92+ 0xFF+ 0x7A+ 0xFF+ 0xFE+ 0x00+ 0x00 
            //value: 'D' character to turn off the led
            msg += "\u0044"
            //updating parcial checksum with value
            sum += 0x44
            //checksum = 0xFF - sum ; then append it to the message, and send it
            sum = 0xFF - sum.bitwiseAnd(0xFF)
            msg += String.valueOf(Character.toChars(sum))
            logInfo( "XBee", "Outgoing message OFF: {}", msg)
            XBeeString.sendCommand(msg)
        }
        if (XBeeLed.state == ON) { 
            //header: |start|length |type |ID |8 byte address |net addr |broad|optio
            var msg = "\u007E\u0000\u000F\u0010\u0000\u0000\u0013\u00A2\u0000\u0040\u0092\u00FF\u007A\u00FF\u00FE\u0000\u0000"
            //determining header parcial checksum
            var int sum = 0x10+ 0x00+ 0x00+ 0x13+ 0xA2+ 0x00+ 0x40+ 0x92+ 0xFF+ 0x7A+ 0xFF+ 0xFE+ 0x00+ 0x00 
            //value: 'L' character to turn on the led
            msg += "\u004C"
            //updating parcial checksum with value
            sum += 0x4C
            //checksum = 0xFF - sum ; then append it to the message, and send it
            sum = 0xFF - sum.bitwiseAnd(0xFF)
            msg += String.valueOf(Character.toChars(sum))
            logInfo( "XBee", "Outgoing message ON: {}", msg)
            XBeeString.sendCommand(msg)
        }
end